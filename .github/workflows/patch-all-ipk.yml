name: VirtualHere Server Patcher and Key Generator

on:
  workflow_dispatch:
    inputs:
      target_sn:
        description: "请输入序列号 (用于安卓密钥模式或完整模式的初始修补)"
        required: true
        default: ""
      device_count:
        description: "请输入客户端设备数量"
        required: false
        default: "63"
      android_key_only:
        description: "是否仅生成安卓免Root密钥？"
        type: boolean
        default: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Environment
        run: |
          # 创建工作目录和输出目录
          mkdir -p tools output/patched_binaries
          # 安装必要的工具 (upx)
          sudo apt-get update
          sudo apt-get install -y upx-ucl

      - name: Extract Activator Tools
        run: |
          # 解压 Linux 版的 activator 工具到 tools 目录
          unzip -o activator2_linux.zip -d tools/
          # 为 activator 添加执行权限
          chmod +x tools/activator

      - name: Generate Android Key Only Mode
        if: ${{ inputs.android_key_only }}
        run: |
          echo "运行模式: 仅生成安卓免Root密钥"
          echo "输入序列号: ${{ inputs.target_sn }}"
          echo "设备数量: ${{ inputs.device_count }}"
          # 生成密钥，使用 'android_mode' 作为任意文件名参数
          ./tools/activator android_mode ${{ inputs.device_count }} ${{ inputs.target_sn }} | tee ./output/android_license_key.txt
          echo "安卓密钥已生成并保存到 output/android_license_key.txt"

      - name: Full Patch Mode
        if: ${{ !inputs.android_key_only }}
        run: |
          echo "运行模式: 完整修补模式"
          echo "初始修补使用的任意序列号: ${{ inputs.target_sn }}"
          echo "设备数量: ${{ inputs.device_count }}"

          # 遍历 ipk 目录下的所有文件
          for server_binary in ipk/*; do
            if [ -f "$server_binary" ]; then
              filename=$(basename "$server_binary")
              echo "正在处理文件: $filename"

              # 复制原始文件到工作区
              cp "$server_binary" .

              # 步骤 1: 尝试解压
              echo "尝试解压 $filename ..."
              if upx -d "$filename"; then
                echo "$filename 解压成功，将继续执行修补和压缩。"
                needs_repack=true
              else
                echo "$filename 解压失败（可能未压缩），将继续执行修补，但跳过压缩。"
                needs_repack=false
              fi

              # 步骤 2: 修补文件 (使用用户输入的任意SN进行初始修补)
              ./tools/activator "$filename" ${{ inputs.device_count }} ${{ inputs.target_sn }}

              # 步骤 3: 如果解压成功，则重新压缩
              if [ "$needs_repack" = true ]; then
                echo "重新压缩 $filename ..."
                upx -9 "$filename"
              fi

              # 将处理后的文件移动到输出目录
              mv "$filename" output/patched_binaries/
              echo "已处理完成: $filename"
            fi
          done

          # 步骤 4: 为完整模式也生成一个最终的密钥（可选，使用真实的SN）
          # 这里假设您之后会用手工输入的真实SN再次生成密钥
          # 如果您希望在此处也为完整模式生成一个密钥，可以取消下面的注释并提供一个SN
          # ./tools/activator full_mode_patch ${{ inputs.device_count }} SOME_REAL_SN_HERE | tee ./output/full_mode_license_key.txt

      - name: Upload Patched Binaries (Full Mode)
        if: ${{ !inputs.android_key_only }}
        uses: actions/upload-artifact@v4
        with:
          name: Patched-Server-Binaries
          path: output/patched_binaries/

      - name: Upload Android License Key
        if: ${{ inputs.android_key_only }}
        uses: actions/upload-artifact@v4
        with:
          name: Android-License-Key
          path: output/android_license_key.txt

      - name: Show Output Info
        run: |
          if ${{ inputs.android_key_only }}; then
            echo "工作流完成！请从 Artifacts 下载 Android-License-Key 获取您的许可证密钥。"
          else
            echo "工作流完成！请从 Artifacts 下载 Patched-Server-Binaries 获取所有已修补的服务器文件。"
            echo "请注意：完整修补模式使用的是您输入的任意序列号进行的基础修补。"
            echo "后续仍需在客户端中查看真实SN，并再次生成密钥进行激活。"
          fi
